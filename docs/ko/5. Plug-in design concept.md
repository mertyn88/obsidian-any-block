(The author's thoughts on the development of this plugin are recorded here...)

AnyBlock의 가장 이해하기 쉬운 기능은 List를 Table로 변환하는 것이지만, 이는 플러그인의 핵심이 아니라 유용한 부가 기능일 뿐입니다.

# 플러그인 카테고리 개념

## 플러그인 분류

먼저 렌더링 유형의 플러그인을 분류해 봅시다 (대체로 OB 플러그인을 관리 유형, 입력 보조 유형, 렌더링 유형으로 나눕니다)
렌더링 유형 중: 현재 대부분의 특수 구문 해석에는 다섯 가지가 있습니다.

1. 대부분 **코드 블록**에서 수행되며, 유명한 것은 Ad의 코드 블록 구문입니다.
   (Ad의 코드 블록을 "특수 인용 블록"으로 사용하는 것은 약간 불편하며, Callout이 상위 대체품이라고 느낄 수도 있습니다)
2. callout은 **인용 블록**에서 수행되며, 다른 것은 본 적이 없습니다.
3. **전체 md 문서**를 구문 해석으로 사용, 예를 들어 Kanban
4. **접두사 방식**, 접두사 식별자에서 빈 줄까지의 영역을 특수 구문 형식의 영역으로 사용합니다. 장점은 이것이 표의 초집합이며, 전통적인 표 구문과 완전히 호환됩니다.
5. **태그 방식** (~~하지만 기존 인터페이스는 직접 지원하지 않으며, 이를 구현하려면 자체 md 후처리기를 다시 작성해야 합니다~~, 이제 작성되었습니다)


## 그들의 각자 장단점

|방식|   |단점|장점|플러그인 예시|
|:----|---|:----|----:|---|
|방식1|   |**Md 구문 해석 불가**, <br> **구문 해석 실패 시 매우 보기 흉해짐** ,<br>**중첩 컨테이너에 속하지 않지만 강제로 중첩 가능**|코드 해석을 사용하여 색상을 입힐 수 있으며, 코드 내용에 적합합니다. md 구문 간섭을 피할 수 있습니다.|플러그인 예: `dataview`, `mermaid` 등 <br> 반례 플러그인이 매우 많습니다, 예: `Ad의 코드 블록 구문`, `채팅 기록 소프트웨어`(Md 정보 전송 버전 지원), 내부에 Md 구문이나 이미지가 포함된 모든 플러그인, `mindmap`(리스트로 생성된 마인드맵)|
|방식2|   |**각 행의 ">" 기호와 중첩 들여쓰기가 매우 번거로움**, 특히 내용이 매우 길 때<br>(코드 블록에 비해)|Md 구문 해석을 사용하여 색상을 입힐 수 있습니다.|플러그인 예: `Ad의 Callout` 구문|
|방식3|   |전체 문서 사용|방법2의 모든 장점을 가지고 있으며, 코드 블록과 인용 블록을 추가할 필요가 없습니다.|플러그인 예: `kanban`, `mindmap`|
|방식4|   |빈 줄이 종료 기호로 필요하기 때문에 일반적으로 중첩 컨테이너로 사용할 수 없으며, 이는 내용에 공백이 있을 수 없음을 의미합니다.|방법2,3의 모든 장점을 가지고 있습니다. 또한 식별자는 앞에만 추가하면 됩니다.|플러그인 예: `list-callout`, <br> `Table Extended`의 `-tx-` 접두사 (필요하지 않지만 가끔 오류 발생),<br>` checklist`의 `#todo` 접두사 (이것은 전체 라이브러리 인식 및 개별 렌더링),<br>`AnyBlock`의 국부 및 제목 선택기|
|방식5<br>--------|   |중첩 구문을 사용하면 들여쓰기가 없어 찾기 어려움|사실 방식4의 분기입니다. 방법2,3의 모든 장점을 가지고 있습니다. 또한 태그는 앞뒤에만 추가하면 됩니다.|플러그인 예: HTML 코드, `AnyBlock`의 시작 및 끝 선택기|


## 왜 대부분의 플러그인이 코드 블록을 통해 구현되나요?

위에서 특수 구문을 다섯 가지로 분류했으며, OB의 구문 해석 유형 플러그인 대부분이 방식1을 통해 구현된다는 것을 알 수 있습니다. 왜 그럴까요?
아마도 이러한 특수 구문은 포함되어야 하며, 본문과 무관하며, 특수 구문의 형식이 잘못 인식될까 두려워서 (md 구문 해석을 피해야 함)일 것입니다.

하지만 어떤 플러그인은 명백히 방식1로 구현하는 것이 불리하지만, 여전히 사용합니다. 예를 들어: Ob가 callout 구문을 지원하기 전의 ad 플러그인은 절호의 예입니다.
(이 플러그인을 비하하는 것이 아닙니다. ad 플러그인은 callout 구문에 많은 지원을 제공하며, 명령을 통해 callout 구문을 빠르게 삽입할 수 있고 (ad 구문이 아님), 설정 패널에서 ad 구문과 callout 구문의 유형을 동시에 확장할 수 있어 매우 유용합니다. `BT 예제 라이브러리`는 ad 플러그인을 사용하여 callout 구문 유형을 확장하는 방법을 활용하여 각 블록의 클래스 유형을 구분하여 확장합니다)

현재 대부분의 플러그인이 코드 블록을 통해 특수 형식을 렌더링할 수 있는 큰 이유는 obsidian이 매우 편리한 API 인터페이스를 제공하기 때문입니다:
```js
this.registerMarkdownCodeBlockProcessor("chat-qq", (source, el, _) => {
	new Chat_qq(source, el, _, this).render()
});

```
이 인터페이스를 구현하기만 하면, 실시간 및 렌더링 모드에서 특수 형식으로 부분 텍스트를 쉽게 렌더링할 수 있습니다.

## 구문 블록 변환

하지만 앞서 말한 것처럼, 다양한 구문 해석 선택기 (여기서는 특수 구문 범위를 선택하는 방식을 선택기라고 부릅니다)는 각각 단점과 장점이 있습니다.
AnyBlock이 하는 일은 이러한 구문 선택 방식을 혼합하는 것입니다. 인용 블록 선택, 코드 블록 선택, 전후 접미사 선택, 기타 방식 모두 AnyBlock을 통해 상호 변환할 수 있습니다.

AnyBlock은 두 가지 방식으로 이를 달성합니다:
1. [블록 변환](5.%20사용 예제%20-%20기반 개념의 유연한 조작.md) 기능을 통해 코드 블록 내에 있지 않은 텍스트를 코드 블록 내에 있는 것처럼 가장합니다.
   이 방법을 통해 거의 모든 코드 블록을 사용하는 플러그인을 처리할 수 있습니다.
2. 플러그인 개발자는 AnyBlock이 제공하는 [새로운 인터페이스](9.%20For%20Developer.md)를 사용하여 새로운 프로세서를 등록하여 처리할 수 있습니다.

또한, AnyBlock은 개발 난이도를 낮춥니다.
1. 원래 코드 블록 외부의 특수 구문 해석 프로그램을 구현하려면 매우 어려울 수 있습니다 (예: callout 구문과 유사한 기능의 플러그인을 만들고 싶을 때).
   하지만 AnyBlock을 전제 플러그인으로 선택하여 사용자가 먼저 이 플러그인을 설치하도록 알릴 수 있으며, OB가 제공하는 코드 블록 등록 모듈만 구현하면 됩니다. 다른 복잡한 것은 구현할 필요가 없습니다!
2. 텍스트 프로세서는 중첩 사용이 가능하며, 즉 컴포넌트를 재사용할 수 있고, 프로세서 간의 결합이 느슨하여 일부 단계에서는 기존 도구를 사용할 수 있으며, 더 이상 직접 휠을 만들 필요가 없습니다.

# 플러그인 카테고리 개념 - 왜 AnyBlock을 사용해야 하나요?

왜 AnyBlock을 사용해야 하나요?
앞서 원리를 설명했지만, 직관적이지 않을 수 있습니다. 여기서 AnyBlock을 사용하여 기존 플러그인을 최적화할 수 있는 몇 가지 예를 들어보겠습니다.

## callout 잡담

앞서 언급한 장단점이 직관적이지 않을 수 있습니다. 이제 예를 보겠습니다:
(이 섹션의 내용을 보기 위해 소스 코드, 실시간, 렌더링 모드를 반복적으로 전환해 보세요)

### Ad 플러그인 작성법

callout 구문이 나오기 전에는 이렇게 작성했습니다:

```ad-note
### 제목

### 제목2

### 제목3

- 일반 목록
  - 일반 목록
	- 일반 목록
  - - 일반 목록

```

### Callout 작성법

callout 구문이 나온 후에는 이렇게 작성했습니다:

> [!note]
> ### 제목
> ### 제목2
> ### 제목3
> - 일반 목록
>  - 일반 목록
>    - 일반 목록
>    - 일반 목록

### Any-Block 작성법

Any-Block (이 플러그인)을 사용하면, 이렇게 작성할 수 있습니다 (작성법이 매우 자유롭습니다)

작성법 1: 시작 및 끝 선택기 작성법

{[code]
ad-note
#### 제목

#### 제목2

#### 제목3

- 일반 목록
  - 일반 목록
	- 일반 목록
  - - 일반 목록
}.

작성법 2: 블록 변환 작성법 (ob가 callout 구문을 지원하지 않는 경우 이렇게 작성할 수 있지만, ob 0.14가 지원하므로 이제는 필요 없습니다. 여기서는 예시로만 제공합니다)

[quote2code]
> ad-note
> ### 제목
> ### 제목2
> ### 제목3
> - 일반 목록
>  - 일반 목록
>    - 일반 목록
>    - 일반 목록

작성법 3: 제목 선택기 작성법:

[!note]
#### 제목

##### 제목2

##### 제목3

- 일반 목록
  - 일반 목록
	- 일반 목록
  - - 일반 목록


## 목록을 표로 변환 list2table

이것은 AnyBlock이 기본적으로 제공하는 매우 유용한 기능 중 하나입니다. 이 기능의 구현이 AnyBlock의 범위 선택 후 처리 능력에 의존하는 것인지 잘 생각해 보세요.
물론 목록 내용을 코드 블록에 넣어 렌더링할 수 있지만, 그렇게 하면 그렇게 유용하지 않을 것입니다.

부가 이야기 1
사실 저자는 먼저 `목록을 표로 변환`하는 플러그인을 구현하려고 생각했고, 이 플러그인을 구현하려면 어떤 문제가 있을지 고민한 후 다양한 플러그인을 "특수 구문 해석" 방식으로 요약하고 `AnyBlock`이라는 플러그인을 제안했습니다. "시작 및 끝 선택기"와 머리 부분만 표시하면 되는 "목록 인용 블록 코드 블록 제목 등 선택기"를 제안했습니다.

부가 이야기 2
이 플러그인을 구현하기 전에 `목록을 표로 변환` 기능을 구현할 수 있는 두 가지 방법이 있었습니다.
하나는 `Bosidian 그룹 친구 @구염`이 작성한 순수 CSS 구현입니다. 단점은... 약간 못생겼습니다.
	(머리 부분 식별자가 필요하지 않은 것은 ab에 비해 장점이 아니며, 사실 anyblock도 머리 부분 식별자가 필요하지 않을 수 있습니다. 설정에서 `항상 선택`을 켜면 되지만, 강력히 권장하지 않습니다)
	(여기서 구현 세부 사항을 조금 공개합니다: AnyBlock은 먼저 머리 부분을 선택한 다음 아래를 선택하는 것이 아니라, 먼저 블록을 선택한 다음 위에 머리 정보가 있는지 확인합니다)
다른 하나는 제가 dataviewjs로 강제로 작성한 시뮬레이션입니다. 단점은 실제로 셀 병합이 없으며, `^^` 기호를 사용하여 셀이 병합된 것처럼 가장합니다.

## chat-view-qq (with md)

다른 용도를 예로 들어보겠습니다:  
예를 들어, 저는 이전에 채팅 기록 플러그인 chat-view-qq를 작성하여 채팅 대화를 빠르게 기록할 수 있었습니다.

나중에 말한 내용을 md 형식으로 렌더링할 수 있도록 하고 싶었습니다. 이 효과를 만들 수 있었지만, 문제가 하나 있었습니다:  
코드 블록에 md 코드를 작성하면 매우 이상하게 보일 것입니다. ob가 callout 구문을 지원하기 전의 ad 플러그인 작성법처럼 말이죠.

## BT 예제 라이브러리 버전 callout 최적화

BT 예제 라이브러리에서는 많은 callout 확장 효과를 AnyBlock으로 작성하여 구문이 더 간단해집니다 (CSS 선택기를 쉽게 선택하기 위해 불편한 작성법을 사용할 필요가 없습니다).
예를 들어 타임라인, 다중 열 등.

## 긴 코드 접기 또는 압축

AB 플러그인에 기본 제공되는 많은 프로세서에서, 이러한 프로세서가 처리하는 범위가 코드 블록이나 인용 블록에만 작성될 수 있다면 그렇게 강력하지 않을 것입니다.
예를 들어: 코드 블록 자동 접기, 코드 블록이 너무 길 때 일부 자동 접기, 코드 변환 문서 등. 코드 블록 위에 프로세서를 작성하면 매우 좋은 효과를 얻을 수 있으며, 간단하고 빠릅니다.

# 목록 변환 개념

AB의 핵심 능력은 범위 선택 및 처리이지만, 많은 사람들이 이 특성에 대해 잘 알지 못합니다.
오히려 더 많은 사람들이 목록을 표로 변환하거나 다른 트리형 다이어그램을 사용하여 AnyBlock을 사용할 수 있기 때문에, 이 플러그인이 왜 List2Table이나 List2Tree라고 불리지 않는지 궁금해할 수 있습니다.

기능적으로 목록 변환은 AnyBlock 선택기에 의존하며, 기능 확장입니다.
하지만 개발자의 구현 의도에서 목록을 트리 구조로 변환하는 것도 AB 플러그인의 핵심 중 하나입니다.

## 공통점 - 트리 구조

트리 구조는 매우 유용한 구조로, 인간이 읽기 쉽고, 보기에도 매우 명확합니다.
목록은 트리 구조를 나타낼 수 있으며, 제한된 범위의 행 병합이 가능한 표, 제한된 범위의 플로우 차트, 제한된 범위의 마인드맵, 괄호 포함 다이어그램, 트리형 트리 다이어그램 등 많은 것들이 트리 구조를 나타낼 수 있습니다.

그렇다면 왜 그들이 상호 변환할 수 없을까요?

## md 표 대체

제 생각에는 ab 확장 목록이 md의 표보다 훨씬 유용합니다.
md 원래의 표 작성법을 완전히 대체하기 위해, 목록을 표로 변환하는 목록에 두 가지 확장 작업을 추가했습니다:
- `| `를 사용하여 인라인 구분을 할 수 있습니다, 표처럼 (미래에는 다른 인라인 구분 기호도 지원할 수 있습니다, 예: `:`, `&`, `/|*/`)
- 첫 번째 행 앞에 `> `를 추가하여 표 머리를 나타낼 수 있습니다.

아래에서 비교해 보겠습니다.

[list2mdutT]
- 비교 항목
	- 예시
	- 소스 코드 가독성
	- 확장성
	- 작성
	- 표 직접 편집
	- 데이터성
- ab 목록
	- 예시
	  ```text
	  [2table]
	  - 테스트1|테스트2
	  - 테스트3|테스트4
	   ```
	- 매우 높으며, 셀 내용이 많을 때 더 뛰어난 성능을 보입니다.
	- md 중첩 허용
	  좌우 중간 정렬은 아직 허용되지 않음
	  일정한 범위의 셀 병합 허용
	- 빠름
	- 새로운 플러그인, 현재는 없지만, 이론적으로 확장하여 가능
	- 강력함, 데이터와 표시가 분리되어 있으며,
	  미래에 데이터를 내보내는 확장을 제작하기 매우 편리합니다.
- md 표
	- 예시
	  ```text
	  |테스트1|테스트2|
	  |---  |---  |
	  |테스트3|테스트4|
		```
	- 매우 높지만, 내장 긴 텍스트 (예: 이미지나 긴 문장)에서 성능이 좋지 않음
	- 소량의 md 스타일 허용
	  좌우 중간 정렬 허용
	  플러그인 table-extend를 사용해야 병합 가능
	- 중간
	- enhance 등 플러그인 사용 가능
	- 약함












